/*
 * Copyright Â© 2024 Service Planet Rotterdam B.V. (it@ask.serviceplanet.nl)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package nl.serviceplanet.closuretemplates.toolbox.msgbundle;

import com.google.common.collect.ImmutableList;
import com.google.template.soy.msgs.SoyMsgBundle;
import com.google.template.soy.msgs.SoyMsgException;
import com.google.template.soy.msgs.restricted.SoyMsg;
import com.google.template.soy.msgs.restricted.SoyMsgBundleImpl;
import com.google.template.soy.msgs.restricted.SoyMsgPart;
import com.google.template.soy.msgs.restricted.SoyMsgPlaceholderPart;
import com.google.template.soy.msgs.restricted.SoyMsgPluralCaseSpec;
import com.google.template.soy.msgs.restricted.SoyMsgPluralPart;
import com.google.template.soy.msgs.restricted.SoyMsgRawTextPart;
import com.google.template.soy.msgs.restricted.SoyMsgSelectPart;
import nl.serviceplanet.closuretemplates.toolbox.msgbundle.icu.MessageFormatTokenType;
import nl.serviceplanet.closuretemplates.toolbox.msgbundle.util.TextUtil;
import nl.serviceplanet.closuretemplates.toolbox.msgbundle.icu.MessageFormatLexer;
import nl.serviceplanet.closuretemplates.toolbox.msgbundle.icu.MessageFormatToken;

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

import static com.google.common.base.Preconditions.checkArgument;

public final class PropertiesIcuParser {
	//	private static final Logger log = LoggerFactory.getLogger(PropertiesIcuParser.class);

	private PropertiesIcuParser() {
		// Not intended to be instantiated.
	}

	static SoyMsgBundle parseIcuMsgsPropertiesFile(String propertyIcuMsgs) {
		List<SoyMsg> messages = new ArrayList<>();

		try (Scanner scanner = new Scanner(propertyIcuMsgs)) {
			while (scanner.hasNext()) {
				SoyMsg msg = parseIcuMsgPropertyLine(scanner.nextLine());
				if (msg != null) {
					messages.add(msg);
				}
			}
		}

		return new SoyMsgBundleImpl(null, messages);
	}

	private static SoyMsg parseIcuMsgPropertyLine(String line) {
		line = line.stripLeading();
		if (line.startsWith("#")) {
			return null;
		}

		List<String> keyValPair = TextUtil.splitWithoutRegex(line, "=", 2);
		if (keyValPair.size() < 2) {
			return null;
		}

		String key = keyValPair.get(0);
		String val = keyValPair.get(1);

		long msgId;
		try {
			msgId = Long.parseLong(key);
		} catch (NumberFormatException e) {
			throw new SoyMsgException(String.format("Invalid message id '%s' could not have been generated by the Soy compiler.", key), e);
		}

		ImmutableList<MessageFormatToken> icuMessageTokens = new MessageFormatLexer(val).tokenize();
		ImmutableList<SoyMsgPart> soyMsgParts = convertToSoyMsgParts(icuMessageTokens);

		if (soyMsgParts.size() > 1) {
			throw new IllegalStateException("Soy {msg}-element can have only 1 root-child, found " + soyMsgParts.size() + " for icu-definition: '" + line + "'");
		}

		return SoyMsg.builder()
				.setId(msgId)
				.setParts(soyMsgParts)
				.build();
	}

	private static ImmutableList<SoyMsgPart> convertToSoyMsgParts(List<MessageFormatToken> icuMessageTokens) {
		ImmutableList.Builder<SoyMsgPart> soyMsgParts = ImmutableList.builderWithExpectedSize(icuMessageTokens.size());

		for (MessageFormatToken icuMessageToken : icuMessageTokens) {
			SoyMsgPart soyMsgPart = switch (icuMessageToken.type()) {
				case TEXT -> SoyMsgRawTextPart.of(icuMessageToken.value());
				case PLACEHOLDER -> new SoyMsgPlaceholderPart(convertIcuRefToSoyPlaceholderName(
						icuMessageToken.value(), icuMessageToken.type())
				);
				case SELECT, PLURAL -> createSoyMsgSwitchBlock(icuMessageToken);
				case EOF -> null;
				default -> throw new SoyMsgException(String.format("Unknown ICU token: '%s'.", icuMessageToken));
			};

			if (soyMsgPart != null) {
				soyMsgParts.add(soyMsgPart);
			}
		}

		return soyMsgParts.build();
	}

	public record SwitchCase<T>(String caseSelector, T caseYieldExpr) {
	}


	private static SoyMsgPart createSoyMsgSwitchBlock(MessageFormatToken messageFormatToken) {
		// examples for select/plural:
		//    {gender,select,male{He uses}female{She uses}other{They use}}
		//    {productCount,plural,=0{You have no products.}=1{You have one product.}other{You have # products.}}
		// notice that, after 'select/plural', we have a sequence of pairs of [text, placeholder]

		String switchBlockDef = TextUtil.extractWrappedText(messageFormatToken.value(), "{", "}");
		List<String> parts = TextUtil.splitWithoutRegex(switchBlockDef, ",", 3);
		checkArgument(parts.size() == 3, messageFormatToken.type() + " switch-block must have format {ref,switch-type,switch-cases-expr}");

		String ref = parts.get(0).trim();
		String type = parts.get(1).trim();
		String expr = parts.get(2).trim();

		if (MessageFormatTokenType.valueOf(type.toUpperCase()) != messageFormatToken.type()) {
			throw new AssertionError();
		}

		String placeHolderName = convertIcuRefToSoyPlaceholderName(ref, messageFormatToken.type());
		List<SwitchCase<?>> icuSwitchCases = parseIcuSwitchCases(expr, type);
		List<SwitchCase<List<SoyMsgPart>>> soySwitchCase = convertIcuSwitchCasesToSoy(icuSwitchCases, placeHolderName);

		// convert switch-cases to one SoyMsgPart
		return switch (type.toLowerCase()) {
			case "select" -> new SoyMsgSelectPart(
					placeHolderName,
					soySwitchCase
							.stream()
							.map(switchCase -> SoyMsgPart.Case.create(
											convertCaseSelectorForSoySelect(switchCase.caseSelector()),
											switchCase.caseYieldExpr()
									)
							)
							.toList());
			case "plural" -> new SoyMsgPluralPart(
					placeHolderName,
					0,
					soySwitchCase
							.stream()
							.map(switchCase -> SoyMsgPart.Case.create(
											convertCaseSelectorForSoyPlural(switchCase.caseSelector()),
											switchCase.caseYieldExpr()
									)
							)
							.toList());
			default -> throw new AssertionError("Unsupported switch-type: '" + type + "'");
		};
	}

	private static List<SwitchCase<?>> parseIcuSwitchCases(String expr, String type) {
		List<MessageFormatToken> parts = new MessageFormatLexer(expr)
				.tokenize()
				.stream()
				.filter(e -> e.type() != MessageFormatTokenType.EOF)
				.toList();
		if (parts.size() % 2 != 0) {
			throw new IllegalStateException("switch-block." + type + ".pair-sequence must have an even number of elements, expr=" + expr);
		}

		List<SwitchCase<?>> cases = new ArrayList<>();
		for (int i = 0; i < parts.size(); i += 2) {
			MessageFormatToken k = parts.get(i);
			MessageFormatToken v = parts.get(i + 1); // cannot go out of bounds

			int pairNr = (i / 2);
			if (k.type() != MessageFormatTokenType.TEXT) {
				throw new IllegalStateException("switch-block." + type + ".pair[" + pairNr + "].key must be TEXT, expr=" + expr);
			}

			cases.add(
					switch (v.type()) {
						case PLACEHOLDER -> new SwitchCase<>(k.value().trim(), v.value().trim());
						case SELECT, PLURAL -> new SwitchCase<>(k.value().trim(), convertToSoyMsgParts(
								new MessageFormatLexer(
										TextUtil.extractWrappedText(v.value().trim(), "{", "}")
								).tokenize()
						));
						default ->
								throw new IllegalStateException("switch-block." + type + ".pair[" + pairNr + "].val unexpected type found: " + v.type() + ", expr=" + expr);
					}
			);
		}
		return cases;
	}

	@SuppressWarnings("unchecked")
	private static List<SwitchCase<List<SoyMsgPart>>> convertIcuSwitchCasesToSoy(
			List<SwitchCase<?>> icuSwitchCases, String placeHolderName) {
		return icuSwitchCases.stream()
				.map(switchCase -> new SwitchCase<>(switchCase.caseSelector(),
						(switchCase.caseYieldExpr() instanceof String caseYieldString)
								? convertIcuExpressionToSoyMsgParts(TextUtil.extractWrappedText(caseYieldString, "{", "}"), placeHolderName)
								: (List<SoyMsgPart>) switchCase.caseYieldExpr()
				))
				.toList();
	}

	private static SoyMsgPluralCaseSpec convertCaseSelectorForSoyPlural(String caseSelector) {
		// =0, =1, =17, ..., zero, one, two, few, many, other
		if (caseSelector.startsWith("=")) {
			return new SoyMsgPluralCaseSpec(Long.parseLong(TextUtil.after(caseSelector, "=")));
		}
		// N.B.: the value 'other' in ICU correctly maps to Soy's default-case.
		return SoyMsgPluralCaseSpec.forType(caseSelector);
	}

	private static String convertCaseSelectorForSoySelect(String caseSelector) {
		// N.B.: the value 'other' in ICU does NOT map to the default-case.
		if ("other".equals(caseSelector)) {
			return null; // use null, as it triggers Soy's default-case.
		}
		return caseSelector;
	}

	private static List<SoyMsgPart> convertIcuExpressionToSoyMsgParts(String text, String placeHolderName) {
		// "You have # products." -> ["You have ", placeHolderName, "products."]
		List<SoyMsgPart> parts = new ArrayList<>();
		for (String segment : TextUtil.splitWithoutRegex(text, "#")) {
			if (!parts.isEmpty()) {
				parts.add(new SoyMsgPlaceholderPart(placeHolderName));
			}
			parts.add(SoyMsgRawTextPart.of(segment));
		}
		return parts;
	}

	private static String convertIcuRefToSoyPlaceholderName(String icuRef, MessageFormatTokenType type) {
		// Soy turns variable 'productCount' into PlaceholderName 'PRODUCT_COUNT_1'.
		// This has nothing to do with ICU, this seems to be how Soy internally
		// handles placeholders, and the i18n MsgBundle has to align with this.
		//
		// Note that IcuSyntaxUtils.convertMsgPartsToEmbeddedIcuSyntax(...)
		// does NOT do the opposite, so it's truly unrelated to ICU.
		//
		// TODO: figure out what determines the (lack of) _N suffix at runtime in Soy.

		if (!TextUtil.isVariableName(icuRef)) {
			throw new IllegalStateException("icu-ref does not seem to be an expected variable-name: '" + icuRef + "'");
		}

		if (TextUtil.isUpperSnakeCase(icuRef)) {
			return icuRef; // assume the var-name is already correctly generated
		}

		String snakeCase = TextUtil.camelCaseToUpperSnakeCase(icuRef);
		if (type == MessageFormatTokenType.PLURAL) {
			snakeCase += "_1";
		}
		return snakeCase;
	}
}
