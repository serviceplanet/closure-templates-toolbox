/*
 * Copyright Â© 2024 Service Planet Rotterdam B.V. (it@ask.serviceplanet.nl)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package nl.serviceplanet.closuretemplates.toolbox.maven;

import com.google.template.soy.SoyToJbcSrcCompiler;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.project.MavenProject;

import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Constructor;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

/**
 * Provides a Maven goal to invoke the Closure Templates (Soy) compiler to compile templates to JVM byte code. The
 * resulting bytecode is then written in to the {@code target/classes} directory where Maven expects to find
 * class files (which contain bytecode).
 *
 * @author Jasper Siepkes <siepkes@serviceplanet.nl>
 */
@Mojo(name = "soy-to-bytecode", defaultPhase = LifecyclePhase.VERIFY)
public final class ClosureTemplatesSoyToJbcMojo extends AbstractClosureTemplatesCompilerMojo {

	/**
	 * Soy compiler CLI flag to specify which JAR files to add to the classpath when compiling externs.
	 */
	private static final String JAVA_EXTERN_DEFN_JARS_FLAG = "--java_extern_defn_jars";
	
	private static final String OUTPUT_FLAG = "--output";

	@Parameter(defaultValue = "${project}", required = true, readonly = true)
	private MavenProject project;

	/**
	 * List of Java JAR files which contain code which is referenced by externs (i.e. Closure Templates style plugins).
	 * Needed when compiling Closure Templates externs.
	 * <br /><br />
	 * Contents are passed to the {@code SoyToJbcSrcCompiler} as arguments of the {@code java_extern_defn_jars} flag.
	 */
	@Parameter(property = "javaExternDefnJars")
	private String javaExternDefnJars;

	/**
	 * Output location where we (temporarily) store the JAR which {@code SoyToJbcSrcCompiler} creates.
	 */
	private Path compiledTemplatesJar = null;

	@Override
	public void execute() throws MojoExecutionException, MojoFailureException {
		try {
			try {
				compiledTemplatesJar = Files.createTempFile("soy-bytecode", ".jar");
				getLog().debug(String.format("Using temporary file '%s' for soy compiler output.",
						compiledTemplatesJar.toString()));
			} catch (Exception e) {
				throw new MojoExecutionException("Unable to create temporary file for compiled templates.", e);
			}

			try {
				getLog().debug("Invoking Soy compiler.");
				SoyToJbcSrcCompiler compiler = createSoyToJbcSrcCompilerInstance();
				
				List<String> compilerCliArgs = generateCliFlags();
				getLog().debug(String.format("About to run Soy compiler with the following CLI arguments: '%s'.", compilerCliArgs));
				
				int exitCode = compiler.run(compilerCliArgs.toArray(new String[]{}), System.err);
				if (exitCode != 0) {
					throw new MojoExecutionException(String.format("Soy compiler exited with non-zero exit code (%s).", exitCode));
				}
			} catch (MojoExecutionException e) {
				throw e;
			} catch (Exception e) {
				throw new MojoExecutionException("The 'SoyToJbcSrcCompiler' was unable to complete successfully.", e);
			}
			getLog().debug("Soy compiler completed successfully.");

			try {
				// Extract the generated JAR file to the classes directory in the Maven target folder.
				extractJar(compiledTemplatesJar, Path.of(project.getBuild().getOutputDirectory()));
			} catch (Exception e) {
				throw new MojoExecutionException("Unable to extract JAR file generated by 'SoyToJbcSrcCompiler' to 'classes' folder.", e);
			}
		} finally {
			if (compiledTemplatesJar != null) {
				try {
					Files.deleteIfExists(compiledTemplatesJar);
				} catch (IOException e) {
					getLog().debug(String.format("Unable to delete temporary JAR output file '%s'.", compiledTemplatesJar), e);
				}
			}
		}
	}

	/**
	 * Generates the "command line" flags and arguments we are going to pass to the Soy compiler.
	 */
	private List<String> generateCliFlags() {
		List<String> compilerCliArgs = generateBaseCliFlags();		
		
		compilerCliArgs.add(OUTPUT_FLAG);
		compilerCliArgs.add(compiledTemplatesJar.toAbsolutePath().toString());

		if (javaExternDefnJars != null && !javaExternDefnJars.isBlank()) {
			compilerCliArgs.add(JAVA_EXTERN_DEFN_JARS_FLAG);
			compilerCliArgs.add(javaExternDefnJars);
		}

		return compilerCliArgs;
	}

	private void extractJar(Path jarFile, Path extractTarget) throws IOException {
		byte[] buffer = new byte[1024];
		try (ZipInputStream zipInputStream = new ZipInputStream(Files.newInputStream(jarFile))) {
			for (ZipEntry zipEntry; (zipEntry = zipInputStream.getNextEntry()) != null; ) {
				Path newPath = Path.of(extractTarget.normalize().toString(), zipEntry.getName());
				if (zipEntry.getName().contains("META-INF")) {
					getLog().debug(String.format("%s - Not extracting.", newPath));
					continue; // We only want classes and resources in the target class directory.
				}

				getLog().debug(String.format("%s - Extracting", newPath));

				if (zipEntry.isDirectory()) {
					if (Files.exists(newPath) && !Files.isDirectory(newPath)) {
						throw new IOException(String.format("Path '%s' exists but is not a directory and should be a directory according to the ZIP file.",
								newPath));
					}

					if (!Files.exists(newPath)) {
						Files.createDirectories(newPath);
					}
				} else {
					// Directories don't always come before files which are in these directories in ZIP files.
					Path newPathParent = newPath.getParent();
					if (Files.exists(newPathParent) && !Files.isDirectory(newPathParent)) {
						throw new IOException(String.format("Path '%s' exists but is not a directory and should be a directory according to the ZIP file.",
								newPath));
					}

					Files.createDirectories(newPathParent);

					try (OutputStream outputStream = Files.newOutputStream(newPath)) {
						for (int len; (len = zipInputStream.read(buffer)) > 0; ) {
							outputStream.write(buffer, 0, len);
						}
					}
				}
			}

			zipInputStream.closeEntry();
		}
	}

	private SoyToJbcSrcCompiler createSoyToJbcSrcCompilerInstance() {
		try {
			Constructor<SoyToJbcSrcCompiler> constr = SoyToJbcSrcCompiler.class.getDeclaredConstructor();
			constr.setAccessible(true);
			return constr.newInstance();
		} catch (Exception e) {
			throw new RuntimeException("Unable to create instance of 'SoyToJbcSrcCompiler' class.", e);
		}
	}
}
